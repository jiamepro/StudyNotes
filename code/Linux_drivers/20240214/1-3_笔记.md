# 一、裸机驱动开发
* 底层，跟**寄存器**打交道，有些MCU提供了**库**。
# 二、Linux驱动开发思维
* 1、Linux下驱动开发直接操作寄存器不现实。
* 2、根据Linux下的各种驱动框架进行开发。一定要**满足框架**，也就是Linux下各种驱动框架的掌握。
* 3、驱动最终表现就是应用程序**操作/dev/xxx文件**。打开、关闭、读写、。。。
* 4、现在新的内核支持**设备树**，这个一个.dts文件，此文件 描述了板子的设备信息。
# 三、Linux驱动开发分类
	linux驱动分为三大类：
	1、字符设备驱动，最多的。
	2、块设备驱动，存储
	3、网络设备驱动，
	一个设备不说是一定只属于某一个类型。比如USB WIFI,SDIO WIFI，属于网络设备驱动，因为他又有USB和SDIO，因此也属于字符设备驱动。
-----------------------------
# 一、应用程序和驱动的交互原理 
* 1、驱动就是获取外设、或者传感器数据，控制外设。数据会提交给应用程序。Linux驱动编译既要编写一个驱动，还要我们编写一个简单的**测试应用程序**，APP。单片机下驱动和应用都是放到一个文件里面，也就是杂糅到一起。**Linux下驱动和应用是完全分开的**。

        用户空间(用户态)和内核空间(内核态)：
        Linux操作系统内核和驱动程序运行在内核空间、应用程序运行在用户空间。

        应用程序想要访问内核资源，怎么办，有三种方法：系统调用、异常(中断)和陷入。

        应用程序不会直接调用系统调用，而是通过API函数来间接的调用系统调用，比如POSIX、API和C库等。unix类操作系统中最常用的编程接口就是POSIX。
        应用 程序使用open函数 打开一个设备文件。

        每个系统调用都有一个系统调用号。
        系统调用处于内核空间，应用程序无法直接访问，因此需要“陷入“到内核，方法就是软中断。陷入内核以后还要指定系统调用号。

# 二、字符设备驱动开发流程
* 1，Linux里面一切皆文件，驱动设备表现就是一个/dev/下的文件，/dev/led。应用程序调用open函数打开设备，比如led。应用程序通过write函数向/dev/led写数据，比如写1表示打开，写0表示关闭。如果要关闭设备那么就是close函数。
* 2，编写驱动的 时候也需要编写驱动对应的open、close，write函数（猜测：这些函数与裸机实现的函数相似）。字符设备驱动fileoptions_struct.

        1、驱动最终是被应用调用的，在写驱动的时候要考虑应用开发的便利性。
        2、驱动是分驱动框架的，要按照驱动框架来编写，对于字符设备驱动来说，重点编写应用程序对应的open、close、read、write等函数。
	
----------------------------------------------
# 一、字符设备驱动框架
* 字符设备驱动的编写主要就是驱动对应的open、close、read。。。其实就是
file_operations结构体的成员变量的实现。
# 二、驱动模块的加载与卸载
* Linux驱动程序可以编译到kernel里面，也就是zImage，也可以编译为模块，.ko。测试的时候只需要加载.ko模块就可以。

编写驱动的时候注意事项！

* 1、编译驱动的时候需要用到linux内核源码！因此要解压缩linux内核源码，编**译linux内核源码**。得到zImage和.dtb。**需要使用编译后的到的zImage和dtb启动系统**。
* 2、从SD卡启动，SD卡烧写了uboot。uboot通过tftp从ubuntu里面获取zimage和dtb，rootfs也是通过nfs挂在。
* 3、设置bootcmd和bootargs

        bootargs=console=ttymxc0,115200 rw root=/dev/nfs nfsroot=192.168.1.66:/home/zzk/linux/nfs/rootfs ip=192.168.1.50:192.168.1.66:192.168.1.1:255.255.255.0::eth0:off
        bootcmd=tftp 80800000 zImage;tftp 83000000 imx6ull-alientek-emmc.dtb;bootz 80800000 - 83000000;

* 4、将编译出来的.ko文件放到根文件系统里面。加载驱动会用到加载命令：insmod，modprobe。移除驱动使用命令rmmod。对于一个新的模块使用modprobe加载的时候需要先调用一下depmod命令。
* 5，驱动模块加载成功以后可以使用lsmod查看一下。
* 6，卸载模块使用rmmod命令
* 7, 加载函数和卸载函数里加printk（内核态），打印调试信息
# 三、字符设备的注册与注销
* 1、在模块初始化函数里，我们需要向系统注册一个字符设备，使用函数register_chrdev。
* 2、卸载驱动的时候需要注销掉前面注册的字符设备，使用函数unregister_chrdev，注销字符设备。
# 四、设备号
* 1，Linux内核使用dev_t

    typedef __kernel_dev_t		dev_t;

    typedef __u32 __kernel_dev_t;

    typedef unsigned int __u32;

* 2、Linux内核将设备号分为两部分：主设备号和次设备号。主设备号占用前12位，次设备号占用低20位。
* 3、设备号的操作函数，或宏
    从dev_t获取主设备号和次设备号，MAJOR(dev_t)，MINOR(dev_t)。也可以使用主设备号和次设备号构成dev_t，通过MKDEV(major，minor)
* 4.register_chrdev 把次设备号全部用了，现在基本不用这个函数注册

# 五、file_operations的具体实现
	struct file_operations {
	struct module *owner;
	loff_t (*llseek) (struct file *, loff_t, int);
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
	ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
	int (*iterate) (struct file *, struct dir_context *);
	unsigned int (*poll) (struct file *, struct poll_table_struct *);
	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
	int (*mmap) (struct file *, struct vm_area_struct *);
	int (*mremap)(struct file *, struct vm_area_struct *);
	int (*open) (struct inode *, struct file *);
	int (*flush) (struct file *, fl_owner_t id);
	int (*release) (struct inode *, struct file *);
	int (*fsync) (struct file *, loff_t, loff_t, int datasync);
	int (*aio_fsync) (struct kiocb *, int datasync);
	int (*fasync) (int, struct file *, int);
	int (*lock) (struct file *, int, struct file_lock *);
	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
	int (*check_flags)(int);
	int (*flock) (struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*setlease)(struct file *, long, struct file_lock **, void **);
	long (*fallocate)(struct file *file, int mode, loff_t offset,
			  loff_t len);
	void (*show_fdinfo)(struct seq_file *m, struct file *f);
#ifndef CONFIG_MMU
	unsigned (*mmap_capabilities)(struct file *);
#endif
};

# 六、字符设备驱动框架的搭建
    Static const struct file_operation  chrdevbase_fops={
        .owner = THIS_MODULE,
        .open = ,
        .release = ,
    }
open函数就按照 file_operation结构体定义的形式去写

# 七、应用程序编写
* 应用程序调用驱动里写的open 等等的函数

* 要调用open，应用程序代码要包含三个库，然后int main(int argc, char **argv     )
	
* Linux下一切皆文件，首先要open

# 八、测	试
1、加载驱动。
modprobe chrdevbase.ko

2，进入/dev查看设备文件，chrdevbase。/dev/chrdevbase。但是实际没有，因为我们没有**创建设备节点**，之后有办法自动创建。
mknod /dev/chrdevbase c 200 0

3、测试
./chrdevbaseAPP /dev/chrdevbase

# 八、chrdevbase虚拟设备驱动的完善
要求：应用程序可以对驱动读写操作，读的话就是从驱动里面读取字符串，写的话就是应用向驱动写字符串。
1、chrdevbase_read驱动函数编写
驱动给应用传递数据的时候需要用到copy_to_user函数。

# 九、总结
1. 用Linux写设备驱动是一个框架性的工作，相比裸机驱动开发比较规范。
2. 个人感觉（还没学到后面）file_operations结构体中open，read，write函数的实现，应该跟裸机编写通信协议比较像，比如实现IIC读写。
3. 正点原子的方式，内核需要编译，还要在宿主机上先编译好uboot，还要配置等等，我想独立学习驱动开发的话，其实，就在Linux电脑上应该也可以实现模块的装载，只是编写模块的config有变化，比如makefile中的KERNEL_DIR还用vscode的includepath需要确定。
4. 非想要编译最新的内核走了弯路，其实那对学习设备驱动作用很小，中断去学系统性不强，之后可以单独学这一步，效率会高一些。
5. 看内核里代码，能让你理解更深入，比如一个文件里描述，系统调用被宏定义抽象成一个系统调用号，open等等函数使用系统调用，其实输入是这些系统调用号，还可以看其他驱动来仿照写自己的驱动，在vscode里search找相应的代码，文件之间有链接关系的话，vscode打开更上一级的文件夹才能search。
6. 由上述可以知道，记住Linux内核的文件结构有必要，方便找相应代码文件增进理解。
7. 属组 属主有什么用？
8. ##结构 将两个分离的连接成标识符，内核里用到的可以反过来巩固C语言基础
9. C++的容器？？
