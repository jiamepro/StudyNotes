# 面试经典150题
[LeetCode-面试经典150题](https://leetcode.cn/studyplan/top-interview-150/)
## 01合并两个有序数组
1. 题目
给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

2. 分析
归并
3. C算法
```
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    int i,j,k,l,temp[nums1Size];
    for(i = m; i < m + n; i++)
        nums1[i] = nums2[i - m];
    for(i=0,j=m,k=0; i<m && j<m+n;k++)
    {
        if(nums1[i]<nums1[j])
            temp[k] = nums1[i++];
        else 
            temp[k] = nums1[j++];
    }
    if(i <= m)
        for(l = i; l < m; l++)
            temp[k++] = nums1[l];
    if(j <= m+n)
        for(l = j; j < m+n; j++)
            temp[k++] = nums1[j];
    for(l = 0; l < nums1Size;l++)
        nums1[l] = temp[l];
}
```

* 写了一个归并算法，其中的思想就是比较一下再挑元素，挑了之后，跳到该数组下一个元素再比再挑，注意最后会有数组有剩余，还要判断哪个是剩余的，把剩余的全给过去。
* 1. 注意数组溢出，检查最后一个元素的位置
* 2. 局部变量可以直接定义在最前面o(1)时间复杂度，不碍事的
* 3. 考虑可能出现的情况，分情况处理，比如输入了两个空数组
* 4. 用数组的空位做temp，可以节约一次数组循环赋值！
* 5. 最后带用例自己心里按算法走一下
* 6. 函数中定义元素个数不确定的数组，不能直接初始化，应该避免

  的数字移到另一个空位，又产生了一个新的空位，空位个数不变，所以总是有空位可以让 nums2的数字填入。
## 02移除元素
1. 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

2. 代码
```
int removeElement(int* nums, int numsSize, int val) {
    int i,j,k=0;
    for(i = 0; i < numsSize; i++)
    {
        if(*(nums + i) == val)
        {
            *(nums + i) = -1;
            k++;
        }
    }
    for(i = 0, j = numsSize - 1; i < j; )
    {
        if(*(nums + i) == -1 && *(nums + j) != -1)
        {
            *(nums + i++) = *(nums + j);
            *(nums + j--) = -1;
        }
        if(*(nums + j) == -1)
            j--;
        if(*(nums + i) != -1)
            i++;
    }
    return numsSize - k;
}

```

* 1. 必须要交换，考虑两个元素的情况（极端元素）（连续if的顺序问题）
* 2. 已经排好了，但条件未满足的情况
* 3. 先操作，后改值，避免条件不应该操作，而先改了用于循环i，j，变得可以操作（连续if的顺序问题）
* 4. 什么时候用连续if，什么时候用if-else，（一次和多次）
* 5. 我写的代码用连续if，表示每次循环都可能进行一次交换，如果不该交换，才会单独改变i或者j (注意逻辑，操作的顺序)