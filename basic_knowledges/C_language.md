# C语言进阶
[toc]
## C专家编程
[C专家编程+清晰+（有书签索引）.pdf](../../../books/C语言/C专家编程+清晰+（有书签索引）.pdf)
看书时间：11月27日-12月10日（13天，24.5h） 
笔记时间：12月11日-12月16日（5天，7h）
预览：C语言的发展历史；语言特性问题及缺陷；声明，分解声明；typedef的用法及typedef与struct连用；指针和数组能不能混用的情况；介绍了动态链接和静态链接，以及interposing问题；可执行二进制代码的段结构，程序运行，堆栈情况，使用setjmp/longjmp用于错误恢复，C语言工具；关于内存，虚拟内存；类型提升，函数原型，C语言实现有限状态机（函数指针），Hash表，强制类型转换；数组和指针可以互换的情况，多维数组；多维数组的内存发布，指针数组；C++的特性；
### 第一章 C语言语法
#### C语言特性
* C语言的特性与硬件十分相关，并且方便编译器设计者
  * 数组下标从0开始——偏移量概念
  * 基本数据类型——底层硬件支持不同数据类型
  * auto 自动内存分配（默认）——方便编译器设计者
  * 表达式中的数组名看做指针——简化编译器
  * 不允许嵌套函数（函数内部包含另一函数定义）——简化编译器
  * register 关键字，把**变量分配到寄存器中**——方便编译器
* C语言中大多数库函数和辅助程序显式调用——C++构造函数和析构函数自动调用
#### 宏的用法
* 预处理器实现三个主要功能：
  * 字符串替换：为常量提供符号名
  * 头文件包含：一般性声明被分离到头文件中，可以被多个源文件使用
  * 通用代码模板拓展：与函数不同，**宏在连续几个调用中所接收参数类型可以不同**
    * 可以用来设计更易理解的代码风格
  * ！！！宏拓展中，空格会影响拓展结果！！！
    ```
    #define a(y) a_expanded(y)
    与
    #define a (y) a_expanded (y)
    后者被拓展为
    a(x) : (y) a_expanded (y)(x)
    ```
  * ！！！在宏里使用花括号不会把多条语句组合成一条复合语句，在C++有新方法可以替代预处理器？？！！！
  * 不要用C语言的预处理器修改语法结构，因为难以维护
    * 宏最好只用来变量命名或简记一些适当结构
    * 宏名应该大写与函数调用分开
#### C语言标准
* ANSI C标准术语：
  * 不可移植的代码（未确定的），坏代码（未定义的，约束条件）
    * 未定义的（不对但标准没规定怎么做），比如标准规定C语言说明的标识符均保留，所以不能声明malloc(),但这不是约束条件，违反它编译器不会警告，导致interpositioning问题
  * 可移植的代码（遵循标准，保证在任何平台都能输出相同，依赖编译器）
  * ！保证可移植性，应该始终加上必要的类型转换、返回值等
  * ！不遵循标准，但不是约束条件，编译器不会给警告......
* 标准规定编译器只**在违反语法规则和约束条件的情况下**才出错误信息
* ANSI C标准的结构：术语，环境，标准，库；附录F：一般警告消息，附录G：可移植性话题（集中建议）
* K＆R C 与 ANSI C的区别：
  * 1. 新的、不同的、重要的东西——**原型**
    * `char * strcpy(char *dst, const char *src);`不要省略形参名
  * 2. 新关键字
  * 3. 安静的改变——相邻字符串字面值会自动连接
  * 4. 除上述三者之外，包括争议内容
* **P19**（分析，不能理解） 实参和形参不相容问题（`char* s`和`const char *p`看似相容，而`char **argv`和`const char **p`不相容）
* const 关键字的作用是限定函数的形参，该函数就不会修改实参指针数据（相反赋值会出错）；const 和 * 的组合通常只在数组形式的参数中模拟传值调用
* 安静的改变——“寻常算数转换”：
  * K＆R C——无符号保留，操作数有无符号数，结果就会转换为无符号
  * ACSI C——值保留，算数运算时，操作数类型不同，就会转换，转换到不丢失信息
    * `if(d <= TOTAL_ELEMENTS - 2)` TOTAL_ELEMENTS为unsigned int（sizeof的返回值是无符号整型），d会被转换为unsigned int，若 d = -1，那会被转换为一个很大的正数导致if一直为假！！！修正这个问题**加强制类型转换**
  * 建议：
    * 少使用无符号类型，尽量使用有符号类型
    * 使用位段和二进制掩码时，才用无符号数
* 代码风格（更通用）：
  * `#define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))` 在不修改define的前提下，可修改数据类型，这段代码更通用
### 第二章 缺陷
#### 字符串
* malloc(strlen(str)+1),考虑字符串结尾的`\0`
* NUL结束字符串，NULL表示空指针
#### switch：fall through
* default位置任意，可以没有
* switch存在问题：
  * 语句只从case处执行，**在花括号后声明局部变量可以，但赋值不会执行**
  * fall through：不会在匹配到的case标签处的语句执行完毕后自动中止，除非遇到break
  * break问题：case与if嵌套，if中使用break也会跳出Switch循环，导致某些语句未执行
#### 字符串合并与逗号
* 相邻字符串常量合并，省略行末加“\”
  * 字符串数值赋值时，漏掉逗号，编译器会直接合并字符串，没有错误信息
  * 拖尾逗号在其他情况，比如枚举说明，单行多变量说明中不允许使用
#### 可见性问题
* 小启发：第一次执行和以后执行时行为不同
  * 通过声明静态变量（函数退出后变量值不变）
  * [静态变量](https://blog.csdn.net/weixin_45797626/article/details/123061899)
    * 静态变量分配在静态存储区，函数退出之后，变量值不变。
    * 在函数内部的基本类型的静态变量初始化语句只有在第一次调用才执行
  ```c
  generate_initializer(char * string) {
      static char separator = ' ';
      printf("%c %s \n",separator,string);
      separetor = ',';
  }
  ```
* C函数默认是全局可见的（extern），限制函数可见在前面加static
  * 会产生interpositioning问题
  * 可见性选择有限
  * 一个大型函数的内部函数不得不在函数外定义，但不加static，他们都是全局可见的，这不合理
#### 符号重载和库函数问题
* 许多关键字和符号被重载（**P37**）：意思模糊和优先级问题
  * sizeof操作数是类型名，两边必须加括号；操作数是变量，则不必加括号
    * p = N * sizeof * q
  * 符号优先级会造成问题**（P38-P39）**
    * 点（偏移）和括号的优先级大于指针
    * 等或不等操作符优先级大于位操作和赋值
    * 算数高于移位；逗号最低
*   表达式有**混合运算，加括号**，同优先级右结合性
*   标准库不安全语意：gets()
    * gets()把超过缓冲区的字符继续写入堆栈，覆盖了原先内容，可以修改堆栈中的过程活动记录，改变函数返回地址
      * > ？？？（堆栈的结构是什么样的，继续写入堆栈会怎么样？数据结构！
      > 2024年1月8日08:20:01：这不是数据结构要涉及的内容，可能跟操作系统相关？？关于操作系统如何运行程序
#### 参数解析，空格，函数返回局部变量
* 参数的解析：区分选项开关和文件名——**p44** shell参数解析
* 多空格问题：\newline and \ newline, 转意newline用于多行宏定义和字符串连续
* 不要空格问题：编译器理解错误 +++ 是 + ++ 还是++ +，*x/*y无空格/*会编译成注释内容，C++新注释 //也可能改变C代码含义
* 不要忘记结束注释
* **P48** 函数返回值是该函数内定义的局部变量会出现问题：函数结束，变量销毁，没人知道指针指向哪里
  * 返回一个指向字符串常量的指针
  * 使用全局声明的数组；缺点在于任何人都有可能修改该数组，且下次调用会覆盖数组内容
  * 使用静态数组；缺点下次调用也会被覆盖
    * 防止修改，拥有该数组指针的函数才能修改其内容
  * 显式分配一些内存，保存返回值；缺点需要承担内存管理
    * 每次调用创建新的缓冲区，不会覆盖以前的返回值
    * 同一代码块进行“malloc”和“free”操作，内存管理最轻松
  * > 为什么不能下次调用覆盖数组？
### 第三章 声明
#### 声明指针
* C语言声明与使用形式相似：int *p；C++：int &p；
* int *p[3] 与 int (*p)[3], 借助优先级判断含义

#### const的顺序,合法声明
* 指针只读：int * const grape；
* 指针所指对象只读：int const * grape；const int * grape
* 练习：char * const * (*next)()：答案**P64**
* **P59** 直接声明器有且只有一个：标识符[],标识符()
* 优先级规则：括号>后缀>前缀，const 和 volatile

#### struct结构体
* `struct {内容...} plum, pear;`结构体后跟变量名，表示这些变量名的类型是这个结构
* `struct fruit_tag {内容...} plum, pear;`struct 后跟“结构标签”,之后可以用`struct fruit_tag`来声明结构体
* 结构中允许填充字段，冒号+位长
  > 结构体中填充字段有什么用？？？深入逻辑元件的编程，系统编程P60
* 与结构相关的参数传参问题
  * int型变量和结构体中int型成员，参数传递方式不同，前者一般传递到寄存器中，后者可能传递到堆栈
  * **P61** 结构体中放数组，可以用赋值语句完成整体赋值，也可以将结构体作为函数参数处理

#### union联合
* 一般用来节省空间，存储不能同时出现的数据项
* 可以把同一数据解释为两种不同的东西：四个字节和32位值
  * 可以提取字节也可以提取32位值，提取字节value.byte.c0

#### enum枚举
* 把一串名字和一串整数值联系，可以用#define代替
* 默认整数值从0开始，后续以此+1
* 枚举名称在调试器中一直可见，调试代码可以使用

#### typedef
* typedef p a..:所有类型为“a..”的都有“p”代替
  * 为类型引入新名字，不是为变量分配空间
  * typedef int （*array_int）[100]: array_int是一个指向一个100个元素的整型数组指针类型
* **P67** 化简声明，简化通用部分
* typedef与#define的区别：
  * typedef定义的类型不能做拓展，如在前加unsigned
  * 连续声明几个变量，typedef保证声明变量均为一种类型
### 第四章 连接
