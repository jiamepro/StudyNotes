# 操作系统
[返回主页](../../research-study/readme.md) 
[返回嵌入式学习](https://github.com/Xiangjiajia-new/StudyNotes/tree/main)
[toc]

参考书：
1. [操作系统：三条简单原理](https://github.com/remzi-arpacidusseau/ostep-translations/tree/master/chinese)
2. [操作系统：三条简单原理(gitee)](https://gitee.com/pj4746/ostep-translations/tree/master/chinese)
3. 嵌入式与实时操作系统(K.C. Wang著)——纸质书


## 知识结构
[操作系统思维导图pdf](../docs/操作系统.pdf)

 ||进程管理|内存管理|文件管理|
---|---|---|---|
抽象|进程 ,并发,线程<br>锁,条件变量<br> |地址空间<br>|文件系统，驱动
机制|受限直接执行<br>进程切换<br>信号量<br>|地址转换<br>分页<br>虚拟内存<br>|日志文件系统
策略|先进先出<br>短任务优先<br>最短完成时间优先<br>轮转<br>多级反馈队列<br>比例份额<br>多处理器调度|缓存管理<br>最优替换策略<br>|文件目录管理<br>存储空间管理

## 操作系统导论

1. 冯诺依曼计算机模型：
   1. 计算机运行程序执行指令的过程：处理器从内存中取指（fetch），对其进行解码（decode），然后执行（execute）它。完成这条指令后，处理器继续执行下一条指令，依此类推，直到程序最终完成。
2. 操作系统
   1. 是一类让程序易于运行的软件，比如实现并发，允许程序共享内存，让程序能够与设备交互，以及其他类似的有趣的工作。
   2. 资源操理器（resource manager）。每个CPU、内存和磁盘都是系统的资源（resource），操作系统**管理（manage）这些资源**，以做到高效或公平，或者实际上考虑其他许多可能的目标。
3. 虚拟化
   1. 操作系统主要利用的一种通用技术，操作系统将物理（physical）资源（如处理器、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式。
4. 系统调用
   1. 操作系统还提供了一些**接口（API）**，可以让用户可以告诉操作系统做什么，从而**利用虚拟机的功能**（如运行程序、分配内存或访问文件或设备）
   2. 典型的操作系统会提供几百个系统调用（system call），让应用程序调用。有时也会说操作系统为应用程序提供了一个标准库（standard library）。
5. CPU虚拟化
   1. 将单个 CPU（或其中一小部分）转换为看似无限数量的 CPU，从而让许多程序看似同时运行
6. 虚拟化内存
   1. 每个进程访问自己的私有虚拟地址空间（virtual address space）（有时称为地址空间，address space），操作系统以某种方式映射到机器的物理内存上。
   2. 实现隔离：一个正在运行的程序中的内存引用不会影响其他进程（或操作系统本身）的地址空间。对于正在运行的程序，它完全拥有自己的物理内存。但实际情况是，物理内存是由操作系统管理的共享资源。
7. 并发问题
   1. 操作系统在同时（甚发地）处理很多事情时会出现的一些问题。
   > 2023年11月24日21:01:56：有哪些并发问题？
   2. 并发问题不局限于操作系统本身，也存在于现代多线程(multi-threaded)程序。
8. 持久性
   1. (针对易失性)在系统内存中，数据容易丢失，因为像DRAM这样的设备以易失（volatile）的方式存储数值。如果断电或系统崩溃，那么内存中的所有数据都会丢失。
   2. 因为用户非常关心他们的数据，我们需要硬件和软件来持久地（persistently）存储数据。
9.  硬盘驱动器和固态硬盘
   1.  硬件以某种输入/输出（Input/Output，I/O）设备的形式出现。
   2.  硬盘驱动器（hard drive）和固态硬盘（Solid-State Drive，SSD）是存储长期保存的信息的通用存储库
10. 文件系统
    1. 操作系统中管理磁盘的软件
    2. 它负责以可靠和高效的方式，将用户创建的任何文件（file）存储在系统的磁盘上。
    3. 不像操作系统为 CPU 和内存提供的抽象，操作系统不会为每个应用程序创建专用的虚拟磁盘。相反，它假设用户经常需要共享（share）文件中的信息。
 11. 机制和策略
     1. 机制是一些低级方法或协议,**实现**了所需的**功能**
     2. 策略是在操作系统内做出**某种决定**的算法
 12. 物理内存模型
     1.  内存模型是从CPU的角度来观察物理内存的分布，而CPU通过总线去访问内存。
 13. 写入协议
     1.  为了处理写入期间系统崩溃的问题
 14. 系统的目标
     1.  建立一些抽象(abstraction),让系统方便和易于使用
     2.  提供高性能(performance)，必须努力提供虚拟化和其他操作系统功能,同时没有过多的开销
     3.  在应用程序之间以及在 OS 和应用程序之间提供保护(protection)。
         1.  让进程彼此隔离是保护的关键
     4.  可靠性；能源效率；安全性；移动性
 15. 操作系统的发展
   16. 库函数时代
      1. 库函数阶段：提供一组常用函数库，提供低级I/O处理的API，使开发人员方便开发
      2. 批处理系统：先把一些工作准备好,然后由操作员以“分批”的方式运行，无交互，浪费用户时间，成本高。
   17. 产生系统调用
      1. 人们意识到现表操作系统运行的代码是特殊的
      2. 系统调用和过程调用之间的关键区别在于,系统调用将控制转移(跳转)到 OS 中,同时提高硬件特权级别(hardware privilege level)。
      3. 通过硬件限制了应用程序的功能，设置权限的转移，实现操作系统代码的隔离，提高了系统的安全性和可靠性
   18. 多道程序时代（小型机）
      1. 解决单作业使用I/O设备时占用CPU的问题，引入多作业切换运行，提高CPU使用率
      2. 实现这一愿景，需要解决内存保护，并发，中断时操作系统运行等等问题
      3. 当时重要的进展之一是引入了UNIX操作系统（1969）
   19. 摩登时代
      1.  一种新型机器，个人电脑出现,便宜,速度更快，适合大众使用
      2.  未吸取小型机时代的经验，比如内存管理等，产生了一次巨大的倒退
      3.  后来小型机的功能进入了台式机
   20. 
关注一些问题，比如如何构建，需要什么，如何利用

## 进程管理
1. 进程
   1. 运行中的程序（操作系统让程序运行起来）
   2. 程序：存在磁盘上面的指令和静态数据
   3. 进程的机器状态：地址空间，寄存器（程序计数器PC，栈指针...）,I/O信息
   4. 进程API：创建，销毁，等待，查询状态，其他控制
      1. 创建：加载——分配堆栈——其他初始化工作（如与I/O设置相关）——跳转到main()入口，启动程序
         1. 尽早加载和惰性加载（分页和交换）
         2. C程序使用栈存放局部变量、函数参数和返回地址
         3. C 程序中,堆用于显式请求的动态分配数据。数据结构(如链表、散列表、树和其他有趣的数据结构)需要堆。
   5. 进程状态：运行态，就绪态，阻塞态
   6. 
2. CPU虚拟化
   1. 用少量的物理CPU造成有无数个CPU可用的假象
   2. 时分共享性CPU技术：让一个进程只运行一个时间片,然后切换到其他进程
   3. 潜在的开销就是性能损失，实现CPU共享，每个进程运行就要慢一点
3. 分离策略和机制
   1. 在许多操作系统中,一个通用的设计范式是将高级策略与其低级机制分开
   2. 将两者分开可以轻松地改变策略,而不必重新考虑机制,因此这是一种模块化(modularity)的形式,一种通用的软件设计原则。
4. 